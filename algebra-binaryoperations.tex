\section{Бинарные операции}

\begin{definition}
	\term{$n$-арной операцией} на множестве $X$ называется функция вида $X^n \to X$. В случае $n=2$ операция называется \term{бинарной}, в случае $n=1$ \term{унарной}. Само значение $n$ называется \term{кратностью} операции.
\end{definition}

\begin{example}
Операции сложения, умножения и возведения в степень натуральных чисел являются бинарными операциями на $\mathbb{N}$. Рассмотренные нами в первой главе логические операции (кроме отрицания) являются бинарными операциями на $\{0,1\}$. Произведение перестановок и в общем композиция функций вида $X\to X$ являются бинарными операциями.
\end{example}

\begin{example}
Вычитание и деление натуральных чисел не являются бинарными операциями, поскольку они определены не для всех элементов $\mathbb{N}$, что противоречит определению.
\end{example}

\begin{example}
Операции над множествами так же не являются бинарными операциями, поскольку эти операции определены для любой пары множеств, но множества всех множеств не существует. Бинарная же операция с точки зрения алгебры должна быть определена именно на множестве. Однако, если рассматривать лишь множества из некоторого универсума (то есть являющиеся подмножествами изначально заданного множества), то операции вроде объединения и пересечения станут бинарными операциями.
\end{example}

В алгебре рассматриваются не только бинарные операции, но и в общем-то любые другие, однако как видно из прошлых частей, именно бинарные операции встречаются наиболее часто. Поэтому мы останавливаемся подробно только на них.

Бинарные операции удобно записывать не как функции ($f(x, y)$), а так, как мы делали это всегда для операций и как мы поступали в случае отношений: указывая символ операции между её аргументами: $xfy$. Использовать для этого конечно удобнее не буквы алфавита, а какие-то специальные символы вроде $+$, $-$ и $\land$.


В случае, если используется $+$, то говорят, что операция записывается в \term{аддитивной} форме. Если аргументы записываются подряд как при умножении ($xy$) или разделяются точкой ($x\cdot y$), то говорят о \term{мультипликативной} форме записи. Конечно же аддитивная форма должна использовать в случаях, когда операция чем-то похожа на простое сложение, а мультипликативная, когда на умножение. В параграфе~4.3 мы придадим более точный смысл этим словам.

В этом параграфе для обозначения бинарных операций мы будем использовать символы $\heartsuit$ и $\spadesuit$, чтобы подчеркнуть, что речь идёт о самых общих бинарных операциях, а не о каких-то конкретных. Для краткости мы будем так же часто опускать слово <<бинарная>> и будем говорить просто об операциях, поскольку ничего кроме бинарных операций у нас пока не предвидится.

Бинарные операции в общем виде на самом деле не слишком интересны. Интересны они становятся в случаях, когда они обладают какими-то дополнительными свойствами.

\begin{definition}
Операция $\heartsuit$ называется \term{ассоциативной}, если
$$x\heartsuit(y\heartsuit z) = (x\heartsuit y)\heartsuit z$$
\end{definition}

\begin{example}
Операции сложения и умножения чисел ассоциативны, а вот возведение в степень~--- нет.
\end{example}

\begin{thm}\label{th:alg_assoc}
Для ассоциативной операции $\heartsuit$ результат вычисления
$$x_1\heartsuit x_2\heartsuit\ldots\heartsuit x_n$$
не зависит от порядка вычисления операций. Другими словами вне зависимости от того как расставить скобки, результат вычисления будет одинаковым.
\end{thm}
\begin{proof}
Доказательство полностью аналогично доказательству по индукции из примера \ref{ex:naturals_assoc}, с той лишь разницей, что теперь мы умножение заменяем на абстрактное $\heartsuit$.
\end{proof}

Теорема \ref{th:alg_assoc} напрашивалась на формулировку уже давно, но у нас не было для этого подходящего инструментария. То что скобки можно расставлять в произвольном порядке мы упоминали для очень многих операций, начиная логикой и заканчивая арифметикой. Однако до введения абстрактного определения <<ассоциативная операция>> формально мы должны были доказывать эту теорему в каждом отдельном случае. Теперь же, когда мы не говорим о конкретной операции, эта теорема стала универсальной. Думаю, хоть слабенькую мотивацию для абстрактный определений этого параграфа это даёт. Далее вы увидите, что на такой абстрактной базе можно развить довольно крутую теорию.

\begin{definition}
Операция $\heartsuit$ называется \term{коммутативной}, если $x\heartsuit y = y\heartsuit x$.
\end{definition}

\begin{example}
Операции сложения и умножения чисел коммутативны, а возведение в степень~--- нет. Произведение перестановок так же некоммутативно.
\end{example}

Хотя на первый взгляд коммутативность~--- удобное свойство, большинство операций, которые мы будем рассматривать, коммутативными не будут. Более того, удивительным образом именно из отсутствия коммутативности будут следовать их интересные и полезные свойства.

\begin{definition}
Элемент $e_L$ называется \term{левым нейтральным} относительно операции $\heartsuit$, если $e_L\heartsuit x = x$. Аналогично определяется \term{правый нейтральный} элемент $e_R$. Если элемент является одновременно и правым, и левым нейтральным, то он называется просто \term{нейтральным}.
\end{definition}

\begin{example}
0 является нейтральным элементном относительно сложения, 1 относительно умножения чисел. 1 является правым нейтральным элементом относительно возведения в степень, но не является левым нейтральным.
\end{example}

Очевидно, что для коммутативных операций разницы между левыми и правыми нейтральными элементами нет никакой.

По аналогии со сложением и умножением в мультипликативной форме записи нейтральный элемент чаще всего обозначается как 1, а в аддитивной как 0.

\begin{thm}
Если для операции $\heartsuit$ существует и правый, и левый нейтральные элементы, то они во-первых совпадают, а во-вторых этот элемент единственен.
\end{thm}
\begin{proof}
С одной стороны, поскольку $e_L$ левый нейтральный, то
$$e_L\heartsuit e_R = e_R$$
Но с другой стороны, так как $e_R$ правый нейтральный, то
$$e_L\heartsuit e_R = e_L$$
Значит $e_R=e_L$ и этот элемент нейтрален. Аналогично доказывается единственность нейтрального элемента, если предположить существование нейтральных элементов $e_1$ и $e_2$ и рассмотреть выражение $e_1\heartsuit e_2$. 
\end{proof}

Обращу внимание, что если существуют только правые нейтральные элементы, или только левые, то их может быть несколько. Пример такой операции приведён в таблице \ref{tb:alg_2neutr}. Такие таблицы называются \term{таблицами Кэли} и они довольно наглядны в учебных целях, хотя совершенно бесполезны на практике: чаще всего мы будем работать либо с бесконечными множествами и операциями на них, либо с классами множеств и операций.

\begin{table}[h]\label{tb:alg_2neutr}
\centering
\begin{tabular}{c|cccc}
$\heartsuit$ & $a$ & $b$ & $e_1$ & $e_2$ \\
\hline
$a$ & $a$ & $a$ & $a$ & $a$ \\
$b$ & $b$ & $a$ & $b$ & $b$ \\
$e_1$ & $b$ & $b$ & $e_1$ & $e_1$ \\
$e_2$ & $a$ & $b$ & $e_2$ & $e_2$
\end{tabular}
\caption{Операция с двумя нейтральными элементами}
\end{table}

В дальнейшем все операции, которые будут представлять для нас интерес с алгебраической стороны, либо не будут иметь никаких нейтральных элементов вообще, либо будут иметь единственный нейтральный элемент. Поэтому изложенное выше в принципе не особо важно для нас, я это рассказал в качестве упражнения для ума и для полноты картины.

\begin{exercise}
Придумайте какую-нибудь коммутативную операцию на каком-нибудь конечном множестве. Нарисуйте для этой операции таблицу Кэли. Каким свойством обладают таблицы Кэли для коммутативных операций?
\end{exercise}

Я думаю это упражнение покажется вам довольно простым, но оно скорее всего возбудит так же в вашем сознании вопрос: а можно ли по внешнему виду таблицы Кэли определить, является ли операция ассоциативной? Увы, ответ тут негативный, вам придётся перебирать все значения (вернее, есть методы, позволяющие сократить перебор, но незначительно). Однако, это не особо большая беда, поскольку в явном виде операции почти никогда не задаются, так что ассоциативность или её отсутствие чаще всего видны из каких-то сторонних соображений.

\begin{definition}
Элемент $x$ называется \term{левым обратным} к $y$ относительно операции $\heartsuit$, если
$x\heartsuit y = e$, 
где $e$~--- нейтральный элемент. Аналогично вводится понятие \term{правого обратного элемента}. Если элемент является одновременно и правым и левым обратным, то он называется просто \term{обратным}.
\end{definition}

Обратите внимание, что если $x$~--- левый обратный к $y$, то $y$ автоматически является правым обратным для $x$. Нас, впрочем, будут опять же главным образом интересовать лишь те операции, где обратные элементы единственны и одновременно и левые, и правые. Понятно так же, что для коммутативных операций значение правых и левых обратных элементов растворяется.

В аддитивной форме записи элемент, обратный к $x$, обозначается как $-x$. В мультипликативной как $x^{-1}$

\begin{exercise}
Среди рассмотренных нами ранее операций лишь немногие имели обратные элементы. Приведите примеры.
\end{exercise}

\begin{exercise}
Придумайте бинарную операцию на каком-либо множестве, такую, что для неё существует элемент, обладающими несколькими различными левыми и несколькими различными правыми обратными элементами.
\end{exercise}

\begin{exercise}
Докажите, что для ассоциативных операций, если элемент имеет и правый и левый обратный элемент, то они совпадают, и этот элемент единственен.
\end{exercise}

\begin{definition}
Операция $\heartsuit$ называется \term{дистрибутивной слева} относительно операции $\spadesuit$, если
$$x\heartsuit (y\spadesuit z) = (x\heartsuit y) \spadesuit (x \heartsuit z)$$
Аналогично определяется \term{дистрибутивность справа}. Если операция дистрибутивна и справа и слева, то говорят просто о \term{дистрибутивности}.
\end{definition}

\begin{example}
Умножение дистрибутивно относительно сложения и разности. Объединение и пересечение множеств, а так же конъюнкция и дизъюнкция дистрибутивны относительно друг друга.
\end{example}

\begin{definition}
	\term{Алгебраической структурой} называется множество с заданными на нём операциями.
\end{definition}

\begin{example}
	Множество $\mathbb{N}$ с заданными на нём операциями сложения и умножения и возведения в степень является алгебраической структурой.
\end{example}

\begin{example}
	Множество логических значений $B\{0, 1\}$ с заданными на нём логическими операциями является логической структурой.
\end{example}

\begin{example}
	Если $X$ --- произвольное множество, то $2^X$ с операциями над множествами так же определяет алгебраическую структуру.
\end{example}

Последние два примера показывают, что алгебраическая структура может иметь операции разной кратности. Так, логическое или $x\lor y$ является бинарной операцией, а отрицание $\neg x$~--- унарной (то есть это отображение $B^n\to B$, где $n=1$).

\begin{definition}
	Пусть $A$ и $B$ --- алгебраические структуры с операциями $f_i$ и $g_i$ соответственно, причём для каждого $i$ кратность $f_i$ равняется кратности $g_i$. Тогда функция $h:A\to B$ называется \term{гомоморфизмом}, если для любых значений $x_k$ и любой операции $f_i$ выполняется тождество
\[
h(f_i(x_1, x_2, \ldots)) = g_i(h(x_1), h(x_2), \ldots)
\]

При этом удобно говорить, что гомоморфизм $h$ переводит операцию $f_i$ в операцию $g_i$.
\end{definition}

\begin{example}\label{ex:alg_epi}
	Рассмотрим множество $\mathbb{N}$ как алгебраическую структуру со сложением и умножением и так же рассмотрим множество $\{0, 1\}$ с операциями <<исключающее или>> и <<и>>. Функция $h:\mathbb{N}\to\{0, 1\}$, отображающая чётные числа в 0, а нечётные в 1, является гомоморфизмом. Под действием этого гомоморфизма получается, что
\[
h(1\times 3 + 2) = (h(1)\land h(3)) \oplus h(2) = (1\land 0) \lor 0
\]
\end{example}


\begin{example}\label{ex:alg_mono}
	Рассмотрим произвольное множество $X$ и его булеан $2^X$. Рассмотрим функцию $h:\{0, 1\}\to 2^X$ со значениями $h(0)=\varnothing$, $h(1)=X$. Легко увидеть, что эта функция является гомоморфизмом, переводящим <<исключающее или>> в объединение множество и операцию <<и>> в пересечение множеств.
\end{example}

Эти примеры показывают, что гомоморфизм позволяет нам некоторым образом сопоставить два множества и операции над ними. Логическая ложь оказывается ставится таким образом в соответствие чётным числам, а истина соответствует нечётным (умножение чётного на нечётное даёт чётное, и так же ложь на истину даёт ложь). Таким же образом логическая истина соответствует целому множеству $X$, а ложь~--- множеству $\varnothing$. Пока это выглядит очень абстрактно, мы это поняли лишь из существования какой-то специально сконструированной функции, но далее я постараюсь помочь читателю развить интуицию относительно этого.

\begin{definition}
	Частные случаи гомоморфизмов, соответствующие частным случаям функций, так же имеют свои названия:
\begin{enumerate}
	\item \term{Изоморфизм} --- биективный гомоморфизм,
	\item \term{Мономорфизм} --- инъективный гомоморфизм,
	\item \term{Эпиморфизм} --- сюръективный гомоморфизм,
	\item \term{Эндоморфизм} --- гомоморфизм вида $X\to X$,
	\item \term{Автоморфизм} --- изоморфизм вида $X\to X$.
\end{enumerate}
\end{definition}

\begin{table}[h]\label{tb:alg_2neutriso}
	\centering
	\begin{tabular}{c|cccc}
		$+$ & $1$ & $2$ & $3$ & $4$ \\
		\hline
		$1$ & $1$ & $1$ & $1$ & $1$ \\
		$2$ & $2$ & $1$ & $2$ & $2$ \\
		$3$ & $2$ & $2$ & $3$ & $3$ \\
		$4$ & $1$ & $2$ & $4$ & $4$
	\end{tabular}
	\caption{Некоторая алгебраическая операция}
\end{table}

\begin{example}
  Пусть алгебраическая структура $A$ над множеством $\{a, b, e_1, e_2\}$ имеет единственную операцию $\heartsuit$ как она определена в таблице \ref{tb:alg_2neutr}. Алгебраическая структура $B$ над множеством $\{1, 2, 3, 4\}$ имеет единственную операцию $+$ определяемую таблицей \ref{tb:alg_2neutriso}. Отображение $h:A\to B$,
  \[
  h(a) = 1, h(b) =2, h(e_1) = 3, h(e_3) = 4
  \]
  является изоморфизмом.
\end{example}

\begin{definition}
	Алгебраические структуры называются \term{изоморфными}, если существует изоморфизм одной структуры в другую. Изоморфность алгебраических структур $A$ и $B$ мы будем обозначать как $A\cong B$
\end{definition}

Очень легко увидеть как я построил таблицу \ref{tb:alg_2neutriso}: в действительности я просто переименовал элементы первоначальной таблицы \ref{tb:alg_2neutr}, не сделав никаких больше изменений. Это и есть смысл изоморфизма: он показывает, что алгебраические структуры, разные на первый взгляд, оказываются по сути одним и тем же. То есть это не более чем переименование. Может показаться, что это слишком тривиальное понятие, чтобы уделять ему внимание, но оно однако перестанет быть столь тривиальным, когда мы начнём анализировать более сложные алгебраические структуры, в том числе бесконечные. В этих случаях оказывается очень полезным для какой-то новой и непонятной алгебраической структуры найти такой изоморфизм, который сразу же покажет что на самом деле из себя структура представляет.

Мономорфизм --- это более слабое понятие чем изоморфизм. Если $h:A\to B$ мономорфизм, то это показывает, что некоторая часть алгебраической структуры $B$ изоморфна $A$. Так, гомоморфизм из примера \ref{ex:alg_mono} является мономорфизмом, и если в этом примере рассмотреть алгебраическую структуру с пересечением и симметрической разностью только над элементами $\varnothing, X \in 2^X$, то полученная структура будет изоморфна структуре с логическими операциями над $\{0, 1\}$. Таким образом, мономорфизм $h:A\to B$ показывает, что какая-то часть структуры $B$ является переименованием структуры $B$, но $B$, возможно, содержит, дополнительные элементы. В каком-то смысле $B$ получается расширением $A$.

Когда существует мономорфизм $h:A\to B$ мы будем так же говорить, что алгебраическая структура $A$ \term{вкладывается} в $B$.

При эпиморфизме некоторые элементы могут быть переименованы одинаково. В примере \ref{ex:alg_epi} все чётные числа переименовываются в 0, все нечётные в 1. Когда я сам только начинал изучать алгебру, мне было удобно об этом думать как о <<склеивании>> элементов множества, после чего каждому склеенному куску присваивалось отдельное имя.

Эндоморфизмы и автоморфизмы имеют аналогичные интерпретации, только вместо гомоморфизмов $h:A\to B$ рассматриваются гомоморфизмы вида $h:A\to A$. Интуитивно это вероятно сложнее понять, так как переименовываются элементы внутри множества, и после этого переименовании операции всё равно оказываются согласованными. Мы это оставим до \S~4.3, где на примерах мы сможем увидеть содержательные автоморфизмы, пока если привести такой пример, он покажется слишком надуманным.

Приведённые примеры подталкивают нас к следующим определению и теореме.

\begin{definition}
	Пусть $A$ --- алгебраическая структура с операциями $\{f_i\}$ и $B\subset A$, причём для любых параметров $$x_1,\ldots,x_n \in B$$ значение операции $f_i(x_1,\ldots,x_n)$ так же принадлежит $B$. Тогда $B$ называется алгебраической \term{подструктурой} $B$.
\end{definition}

\begin{example}
	Если рассмотреть множество $A = \{x\in \mathbb{N}|x>10\}$ с обычными операциями сложения и умножения, то это будет алгебраическая подструктура для $\mathbb{N}$. Действительно, если ${x,y>10}$, то и $x+y, xy>10$, а стало быть результаты сложения и умножения элементов из $A$ приводят к результату в $A$.
\end{example}

Часто так же говорят, что множество \term{замкнуто} относительно определённых операций, если результат этих операций принадлежит тому же множеству. Таким образом можно говорить, что подструктура~--- это подмножество, замкнутое относительно всех операций алгебраической структуры.

\begin{exercise}
	Докажите, что множество чётных чисел является алгебраической подструктурой множества натуральных чисел с операциями умножения и сложения.
\end{exercise}

\begin{thm}
	Пусть $h:A\to B$ --- гомоморфизм. Тогда образ $h(A)$ является алгебраической подструктурой в $B$.
\end{thm}
\begin{proof}
	Пусть $g$ --- произвольная операция алгебраической структуры $B$ и $f$~--- соответствующая ей операция в $A$. То есть $h(f(\ldots))=g(h(\ldots)\ldots)$. Пусть также $y_1,\ldots,y_n\in h(B)$. Тогда для каждого из $y_i$ найдётся $x_i$ такой что $y_i=h(x_i)$. Используя это можно провести следующее рассуждение:
	\[
	g(y_1,\ldots,y_n) = g(h(x_1),\ldots,h(x_n)) = h(f(x_1,\ldots,x_n)) \in h(A)
	\]
\end{proof}