\section{Невычислимое, недоказуемое}

В этом параграфе мы поговорим о совсем отвлечённых темах. Можно было бы это всё не рассказывать, но мне изложенное кажется очень уж удивительным, поэтому не могу молчать. Разговор будет совершенно не формальным, а больше ознакомительным. Материал этого параграфа не является необходимым для дальнейшего чтения учебника, так что если что-то станет совсем не понятно, то это можно смело пропускать. Впрочем, если вы поймёте изложенное, то, думаю, получите от этого удовольствие.

Предположим, что у нас есть какое-то логическое утверждение, зависящее от натурального числа $P(n)$. Это утверждение, предположим, можно легко проверить для любого конкретного числа, но не понятно верно ли оно для любого числа.

Например, можно рассмотреть \term{гипотезу Гольдбаха} о том, что любое чётное число может быть представлено в виде суммы двух простых чисел (так, например, $50=19+31$ или $100=11+89$). Для любого конкретного чётного числа можно довольно легко перебором подобрать его разложение на сумму двух простых чисел. По крайней мере, всегда у людей это получалось. А вот возможно ли это сделать в общем случае, то есть если получится представить в виде суммы двух простых вообще любое чётное число~--- вопрос, на который наука пока не нашла ответа.

Или вот можно рассмотреть \term{последовательности Коллатца}. Начальный элемент последовательности~--- это произвольное натуральное число, которое мы обозначим как $K_0$. $K_{n+1}$ получается из $K_n$ по следующему правилу: если $K_n$ чётное, то $K_{n+1}=\frac{K_n}{2}$. Если $K_n$ нечётное, то $K_{n+1} = 3K_n  + 1$. Например, если за $K_0$ принять число 15, то мы получаем следующую последовательность:
$$15, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1$$
Как видим, последовательность пришла в единицу. До сих пор с какого бы числа люди не начинали писать последовательность Коллатца, она всегда приходит в единицу, но приходит ли она в единицу всегда, или всё же есть исключения~--- никто не знает, это открытый вопрос математики.

Интуитивно должно казаться ясным, что чтобы ответить на такие вопросы, не достаточно перебрать просто большое количество вариантов. В обоих упомянутых проблемах математики перебрали уйму чисел (фактически все числа, на которые хватило вычислительных возможностей), но примера, чтобы какое-то число не раскладывалось в сумму двух простых или чтобы последовательность Коллатца для него не приходила в единицу, так и не нашли. Доказывает ли это что-либо? Конечно нет, потому что чисел, которых математики не проверили, куда больше~--- их ещё целая бесконечность, а проверена лишь малая конечная часть.

Так вот. Примерно 50 лет тому назад было доказано, что на самом деле для почти любого утверждения достаточно проверить лишь конечное число случаев. То есть если вплоть до некоторого номера $M$ нам не встретятся чётные числа, не представимые в виде суммы двух простых, или не встретится последовательность Коллатца, не приходящая в единицу, то такие числа нам не встретятся вовсе никогда.

\begin{thm}
Для установления истинности почти любого утверждения $P(n)$ достаточно проверить лишь истинность конечного числа утверждений $P(n)$ для $n$ от 1 до некоторого $M$.
\end{thm}
\begin{proof}
Давайте представим себя на минуточку программистами. Мы хотим найти такое число $f\in\mathbb{N}$, что $P(f)$ окажется неверным, то есть мы ищем контрпример к нашей гипотезе.

Будем считать, что мы можем написать программу для проверки утверждения $P$ для любого конкретного номера (это предположение и составляет значение слова <<почти>> в формулировке теоремы). Напишем программу, которая будем перебирать все числа подряд начиная единицей и которая остановится лишь когда она найдёт такое $f\in\mathbb{N}$, что $P(f)$ не выполняется. Возможно, что мы не найдём его никогда и тогда программа будет работать бесконечно долго, а это значит, что у нас есть время попить чай и поразмышлять.

Код нашей программы имеет конечную длину, обозначим её N. Если рассмотреть все возможные программы длины $N$, то среди них найдутся конечно же те, которые будут работать бесконечно долго (можно сказать, что они <<зависнут>>) и те, которые в итоге остановятся. Обозначим за $B_N$ самое долгое время работы программы длины $N$ (на английском эти числа называются Busy Beaver Numbers по фольклорным причинам, а как это адекватно переводится на русский, я и не знаю). Как вычислить это самое $B_N$ не очень понятно, но такое число вполне определено. Предположим пока, что мы его знаем.

Посмотрим на часы, сколько уже работает наша программа по поиску контрпримера, пока мы пили чай? Что? Уже дольше, чем $B_N$? Но ведь $B_N$ это самое долгое время, которое может работать программа, которая останавливастся. Значит мы знаем, что программа не остановится уже никогда, то есть контрпример не будет найден. Утверждение об истинности $P$ можно считать доказанным, программу можно выключать.

Конечно же, наша программа за конечное время $B_N$ успела проверить лишь конечное число вариантов от 1 до некоторого $M$, но из рассуждений, приведенных выше, следует, что нам этого каким-то образом оказалось достаточно для того, чтобы утверждать об истинности $P$ для совсем любого $n$. В чём тут подвох? Подвоха тут нет. 
\end{proof}

Задумайтесь на секундочку: почти любой сложный вопрос математики, касающийся натуральных чисел, может быть установлен путём перебора конечного числа вариантов. Будь то теорема Ферма, гипотеза Гольдбаха, Коллатца или кого ещё: достаточно проверить конечное число случаев. Не знаю как вам, но на меня в своё время этот факт произвёл неизгладимое впечатление.

Насколько этот результат практичен? На самом деле совершенно не практичен. Во-первых, не понятно как вычислить значение $B_N$. Во-вторых, даже если мы его вычислим для какого-то $N$, то оно наверняка окажется настолько гигантским, что вряд ли поместится в наш калькулятор. Так что выгоды мы из этого всего извлечь судя по всему не сможем, увы. Но сам факт!

Логично было бы, если бы после изложения этого результата я тут же показал бы, как считать числа $B_n$, однако сейчас мы уйдём в сторону и я покажу как эти числа ещё можно было бы использовать, если бы они были в нашем распоряжении.

Попробуем написать такую программу, которая будет анализировать другую программу, и говорить нам о том, зависнет она или же нормально остановится. Можно рассматривать такую программу как функцию $H:P\to\{0,1\}$, где $P$~--- множество всех возможных программ. 0 означает, что программа зависнет, 1 что остановится.

При условии, что мы можем написать программу, вычисляющую $B_n$, мы нашу задачу можем очень легко решить. Пусть нам дана программа $x$ длины $n$, для которой надо установить остановится ли она. Поскольку программа~--- это просто описание каких-то действий, мы можем заставить выполнять эти действия не компьютер, а нашу программу $H$, то есть мы как бы будем симулировать выполнение программы $x$ внутри программы $H$. Это не сложно технически, но я не буду углубляться в детали как это реализуется. Если вы знакомы с компьютерными технологиями, то наверняка слышали про интерпретаторы, виртуализацию, виртуальные машины и подобное. Это именно то, это возможно и это не особо сложно.

По ходу выполнения программы $x$, программа $H$ будет считать, как долго $x$ работает. Если вдруг окажется, что программа $x$ работает дольше, чем время $B_n$, то мы знаем, что она не закончится, и $H$ останавливает $x$, выдавая нам результат 0. Если же $x$ остановится сама раньше, то $H$ даст результат 1. Вроде всё.

А теперь давайте напишем такую программу $A$, которая так же будет принимать на вход какую-то другую программу $x$, затем будет запускать на ней программу $H$, и если $H(x)=1$, то $A$ будет зависать (например, начнёт считать все натуральные числа подряд), а если же $H(x)=0$, то она будет возвращать какой-то результат. Такую программу так же легко написать.

Попробуем понять какой результат мы получим, если на вход программе $A$ мы дадим её же саму, то есть попробуем выполнить $A(A)$. Что будет? Предположим, что $H(A)=0$, тогда программа $A$ должна завершиться, вернув результат. Но это противоречит тому, что $H(A)=0$. Из этого противоречия видно, что $H(A)\not=0$. Пусть теперь $H(A)=1$, но тогда $A$ должна зависнуть, что противоречит тому, что $H(A)=1$, а значит $H(A)\not=1$. Как так? $H$ оказывается не равно ни одному своему возможному значению!

Это противоречие означает, что программа $H$ не может быть написана, не существует такой программы и существовать не может. Но как так, ведь мы же чётко указали, как её можно написать! Если вглядеться, то при описании работы программы $H$ мы опирались на то, что мы можем как-то вычислить числа $B_n$, но мы не показывали этого. И это единственный момент во всём рассуждении, который мы никак не обосновали. Значит, числа $B_n$ вычислить невозможно.

Тот факт, что есть такая функция $B$, которая вполне определена, но которую невозможно вычислить, может показаться невероятным. На самом деле если подумать, то это довольно не сложно. Из определения функции $B$ мы могли бы попробовать вычислить $B(n)$, запустив одновременно все возможные программы длины $n$, и, заведя таймер, пытаясь понять, какое самое большое время работы программы. Однако с учетом того, что есть программы, которые зависают, мы никогда не узнаем, когда таймер пора выключать, хотя конечно же такой момент во времени существует. Это и есть пример того, что функцию невозможно вычислить.

Мы получили два результата.

\begin{thm}
Невозможно написать программу, которая бы могла по коду другой программы определить остановится ли она или зависнет.
\end{thm}
\begin{thm}
Числа $B_n$ невычислимы. Другими словами невозможно определить максимальное время, которое может работать независающая программа длины $n$.
\end{thm}

Приведённые рассуждения можно вывернуть ещё и вот под каким углом. Напишем программу $E$, которая будет проверять истинность произвольного утверждения $x$ путём последовательного перебора всех возможных доказательств (программа может начинать с коротких доказательств и постепенно переходить к более длинным, так что такая программа определённо может быть написана). Если предположить, что всё можно доказать или опровергнуть, то через какое-то время наша программа либо найдёт доказательство для $x$, либо доказательство для $\neg x$.

Используя эту программу, однако, мы опять же легко можем написать пресловутую программу $H$ проверяющую, остановится ли программа $y$ или нет. Просто вместо запуска программы $y$ и ожидания времени $B_n$ мы на этот раз будем искать доказательство остановки или зависания $y$. Поскольку мы уже знаем, что программа $H$ не может существовать, наше предположение, что программа $E$ всегда либо найдёт доказательство $x$ либо $\neg x$ так же не верно. Это значит, что существуют такие утверждения $x$, которые невозможно ни доказать ни опровергнуть. Как вы вероятно помните, это есть ни что иное как теорема Гёделя о неполноте:

\begin{thm}
Существуют утверждения, которые невозможно ни доказать ни опровергнуть.
\end{thm}

Я упомянул, что числа $B_n$ окажутся скорее всего довольно большими. Оказывается, мы можем примерно прикинуть насколько именно большими они будут.

\begin{thm}
Числа $B_n$ с ростом $n$ растут быстрее, чем любая последовательность, которую мы могли бы вычислить.
\end{thm}
\begin{proof}
Предположим, что это не так, и что существует некоторая последовательность $x_n$ такая, что мы можем её вычислить и что $B_n\le x_n$. Но тогда мы можем запустить все программы длины $n$ и останавливать их как только они отработают время $x_n$. Среди программ, остановившихся раньше, выберем ту, что работала дольше. Время, которое она работала~--- это и есть $B_n$. Но это значит, что мы смогли их вычислить, а это противоречит теореме 3.51. Значит, такой последовательности $x_n$ всё же не существует.
\end{proof}

\begin{exercise}
Если предположить, что мы имеем в нашем распоряжения числа $B_n$ и неограниченный вычислительный ресурс, проверка истинности произвольных утверждений может всё равно вызывать трудности. Гипотеза Коллатца является как раз таким примером. Если наша программа поиска контрпримера не остановилась за время $B_n$, то она не остановится действительно никогда, но это может иметь разное значение: либо она нашла такое $m$, что последовательность Коллатца для него будет бесконечной (и соответственно программа будет бесконечно долго вычислять её значения), либо же что она такого $m$ никогда не найдёт. Таким образом мы не получили из работы программы никакой полезной информации. Однако простая модификация алгоритма поиска контрпримера может всё таки дать нам способ понять, найден ли контрпример, либо же он не будет найден никогда. Придумайте эту модификацию.
\end{exercise}

\begin{exercise}
\term{Великая теорема Ферма} (на английском её называют последней теоремой) утверждает, что уравнение
$$x^n + y^n = z^n$$
не имеет решений для $n>2$. Покажите, как можно было бы её доказать при неограниченном вычислимом ресурсе и известных $B_n$.
\end{exercise}

У Великой теоремы Ферма интересная история. Ферма сформулировал её в 1637 году в виде пометки на полях книги, которую он читал. Там же он указал, что он нашёл элементарное доказательство этой теоремы, но поскольку места недостаточно, он его приводить не будет. В итоге первое доказательство этой теоремы появилось только в 1994 году (спустя 356 лет!) и занимало оно 130 страниц. В этом доказательстве спустя год была найдена ошибка, которую ещё год исправляли. В итоге финальное доказательство без ошибки было представлено лишь в 1996 году. Такая вот история.

В заключение этого параграфа я замечу, что, конечно, всё написанное здесь очень неформально. Из написанного мной совершенно, например, не понятно каким образом компьютерные программы увязываются с аксиоматикой натуральных чисел и теорией множеств. Так же совершенно не понятно что именно из себя представляют сами программы. Использовать в качестве модели реальные компьютеры и реальные языки программирования не получится, так как в реальных системах есть много факторов, которые мешают идеализированному математическому описанию вычислительного процесса: механизмы мультипоточности, пайплайнинг, всякие мьютексы, графический интерфейс, ввод-вывод и вот всё подобное не дают оставляют возможности рассуждать о вычислениях абстрактно.

Чтобы избавиться от всех мешающих факторов реальных компьютеров используется модель \term{машины Тьюринга}, которая представляет собой видимо самую простую модель компьютера. Я не буду её описывать, но если вы хотите понять как примерно устроен формализм того, что я здесь изложил, вы можете поискать статьи о ней и о том, как она соответствует реальным вычислительным машинам, рекурсивным функциям и понятию множеств. Так же рекомендую почитать трагичную и важную биографию самого Алана Тьюринга: будучи блестящим учёным, работающим в области вычислимости и криптографии (значительным образом, благодаря именно его работе союзники могли перехватывать шифрованные сообщения Германии во Вторую Мировую войну; теорема~3.50 так же была сформулирована и доказана именно им), он был обвинён в гомосексуальных связях и принуждён к химической кастрации и употреблению гормональных таблеток <<для лечения гомосексуализма>>. Закончилась история лишением его всех военных наград и званий, а так же полным запретом на занятия наукой. Итогом таких мер по борьбе с гомосексуализмом стал его суицид.

Сегодня ему ставят памятники, его именем названа самая престижная награда в области компьютерных наук. На этой трагичной ноте мы и закончим эту главу.
